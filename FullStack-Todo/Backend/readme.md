# ***Keypoints***
*   **`trim: true`** only removes spaces from the **start and end** of the string. It does **NOT** touch spaces in the middle.
*   Always include the **file extension (`.js`)** in imports when using ES modules in Node.js. This is a common source of errors.
*   Mongoose will apply these transformations (like `trim` and `lowercase`) when you create or save the document. No need to manually style them in the controller; the schema handles it automatically.
* 'this' refers to the current document being saved.
In an arrow function, this is lexically scoped, meaning it doesnâ€™t bind its own this.
Instead, it uses the this of the parent scope. So this would NOT refer to the document
Use _id for database operations (queries, updates)
Use id when you need the ID as a string in your application logic

### JWT Authentication Flow

- `jwt.verify()` checks if the **access token** is present and valid.  
- If the **access token** is **valid** â†’ the user is allowed to enter the website.  
- If the **access token** is **expired** â†’ it then checks if a **refresh token** is present. but for access token it wont compare direclty give access to the user!  
- If the **refresh token** is **valid** â†’  
  - `jwt.verify` verifies the refresh token.  
  - Then it compares the refresh token with the one stored in the database.  
- If the **refresh token** is also **expired** â†’  
  - The user must re-enter their credentials.  
  - Logging in again will generate a **new access token** and **refresh token**.  
  - These are saved in the cookie, and the **old refresh token** in the database is updated with the new one.  

âš¡ In any case, the **access token** and **refresh token** are never removed from the cookie until new ones are issued to replace them.

select: false does
By default, whenever you query a User, Mongoose will exclude the password field from the result.

## Bash command
openssl rand -base64 32

# ***Difference***
Both methods are valid, but they have slightly different use cases and behaviors.
### Method 1: `User.create()`
```javascript
const newUser = await User.create({
  username: username,
  email: email,
  password: password,
});
```
### Method 2: `new User()` + `.save()`
```javascript
const newUser = new User({
  username: username,
  email: email,
  password: password,
});
await newUser.save();
```
---
### Key Differences:

| Feature | `User.create()` | `new User()` + `.save()` |
| :--- | :--- | :--- |
| **Purpose** | **One-step** creation and saving. | **Two-step** process: instantiation then saving. |
| **Syntax** | Shorter, more concise. | More verbose, but offers more control. |
| **Middleware** | Triggers `save` middleware (e.g., `pre('save')`). | Also triggers `save` middleware. |
| **Validation** | Validates before saving. | Validates on `.save()`. |
| **Control** | Less control between creation and save. | **More control.** You can modify the document before saving. |
| **Bulk Operations** | Can create multiple documents at once (`User.create([...])`). | Only creates one document at a time. |

---







# ***Visited sites***
- [zod](https://www.npmjs.com/package/zod?activeTab=versions)
- [bcrypt](https://www.npmjs.com/package/bcryptjs/v/2.4.3)

They serve **different layers of validation**:
* **Zod** â†’ request validation (ensures bad data never reaches the DB).
* **Mongoose** â†’ schema-level validation (last line of defense, keeps DB consistent).
Best practice: **Use both.**
* Zod: For input validation at the controller level (`req.body`, `req.params`, `req.query`).
* Mongoose: For database-level consistency.

### ***Difference***

#### 1. `validationResult.error.message`

* This is a **single string** generated by Zod.
* Zod takes *all the validation issues* and merges them into one string.
* Example:

  ```json
  "2 validation issues: Email is required, Password must be at least 8 characters"
  ```

#### 2. `validationResult.error.errors.map(err => err.message)`

* Here, `validationResult.error.errors` is an **array of individual error objects** (one for each field/constraint that failed).
* Each `err.message` is the custom message you wrote in your Zod schema.
* The `.map(...)` collects all those messages into an **array of strings**.
* Example:

  ```json
  [
    "Email is required",
    "Password must be at least 8 characters"
  ]
  ```

---

#### ðŸ”‘ Summary
* `.error.message` â†’ **one combined string** (Zodâ€™s summary).
* `.error.errors.map(err => err.message)` â†’ **array of all individual error messages** (more structured, better for frontend).
